import warnings
from math import sqrt, sin, cos

import numpy as np


def create_spiral(r1, r2, N):
    """
    Creates a "propagating spiral", often used as an easy mitotic-like
    starting conformation.

    Run it with r1=10, r2 = 13, N=5000, and see what it does.
    """
    Pi = 3.141592
    points = []
    finished = [False]

    def rad(phi):
        return phi / (2 * Pi)

    def ang(rad):
        return 2 * Pi * rad

    def coord(phi):
        r = rad(phi)
        return r * sin(phi), r * cos(phi)

    def fullcoord(phi, z):
        c = coord(phi)
        return [c[0], c[1], z]

    def dist(phi1, phi2):
        c1 = coord(phi1)
        c2 = coord(phi2)
        d = sqrt((c1[1] - c2[1]) ** 2 + (c1[0] - c2[0]) ** 2)
        return d

    def nextphi(phi):
        phi1 = phi
        phi2 = phi + 0.7 * Pi
        mid = phi2
        while abs(dist(phi, mid) - 1) > 0.00001:
            mid = (phi1 + phi2) / 2.0
            if dist(phi, mid) > 1:
                phi2 = mid
            else:
                phi1 = mid
        return mid

    def prevphi(phi):

        phi1 = phi
        phi2 = phi - 0.7 * Pi
        mid = phi2

        while abs(dist(phi, mid) - 1) > 0.00001:
            mid = (phi1 + phi2) / 2.0
            if dist(phi, mid) > 1:
                phi2 = mid
            else:
                phi1 = mid
        return mid

    def add_point(point, points=points, finished=finished):
        if (len(points) == N) or (finished[0] == True):
            points = np.array(points)
            finished[0] = True
            print("finished!!!")
        else:
            points.append(point)

    z = 0
    forward = True
    curphi = ang(r1)
    add_point(fullcoord(curphi, z))
    while True:
        if finished[0] == True:
            return np.array(points)
        if forward == True:
            curphi = nextphi(curphi)
            add_point(fullcoord(curphi, z))
            if rad(curphi) > r2:
                forward = False
                z += 1
                add_point(fullcoord(curphi, z))
        else:
            curphi = prevphi(curphi)
            add_point(fullcoord(curphi, z))
            if rad(curphi) < r1:
                forward = True
                z += 1
                add_point(fullcoord(curphi, z))


def _spherical_to_cartesian(u, theta):
    x = np.sqrt(1.0 - u**2) * np.cos(theta)
    y = np.sqrt(1.0 - u**2) * np.sin(theta)
    z = u

    return x, y, z


def _random_points_sphere(N):
    theta = np.random.uniform(0.0, 1.0, N)
    theta = 2.0 * np.pi * theta

    u = np.random.uniform(0.0, 1.0, N)
    u = 2.0 * u - 1.0
    
    return np.vstack([theta, u]).T

def _gen_random_points_sphere(buffer_size=100):
    """
    Generator which will yield an infinite sequence of random points on a sphere.
    Points are generated in batches of buffer_size.
    """
    points = np.array([])

    while True:
        points = _random_points_sphere(buffer_size)
        yield from points

def create_random_walk(step_size, N, segment_size=1):
    """
    Creates a freely joined chain of length N with step step_size.

    Parameters
    ----------
    step_size: float
        The size of a step of the random walk.
    N : int
        The number of steps
    segment_size : int
        The number of particles of each segment of the chain, generated by repeating a random step for each particle of the segment. Default is 1. Note: The last segment might be shorter than the other segments if N is not divisble by segment_size.

    """
    
    theta, u =  _random_points_sphere(-(N // -segment_size)).T
    dx, dy, dz = (np.repeat(step_size * p, segment_size) for p in _spherical_to_cartesian(u, theta))
    x, y, z = np.cumsum(dx), np.cumsum(dy), np.cumsum(dz)
        
    return np.vstack([x, y, z]).T[:N]


def create_constrained_random_walk(N, 
    constraint_f, 
    starting_point = (0, 0, 0),
    step_size=1.0,
    segment_size=1,
    uniform_segment_lengths=False
    ):
    """
    Creates a constrained freely joined chain of length N with step step_size.
    Each step of a random walk is tested with the constraint function and is
    rejected if the tried step lies outside of the constraint.
    This function is much less efficient than create_random_walk().
   
    Parameters
    ----------
    N : int
        The number of steps
    constraint_f : function((float, float, float))
        The constraint function. 
        Must accept a tuple of 3 floats with the tentative position of a particle
        and return True if the new position is accepted and False is it is forbidden.
    starting_point : a tuple of (float, float, float)
        The starting point of a random walk.
    step_size: float
        The size of a step of the random walk.
    segment_size : int
        The number of particles of each segment of the chain, generated by repeating a random step for each particle of the segment. Default is 1.
    uniform_segment_lengths : bool
        If True segments will be kept to a uniform length, otherwise they will be cut off early if a particle violates the constraint. Default is False. Note: The last segment might be cut short regardless of this flag if N is not divisible by segment_size - 1.

    """
    
    out = np.full((N, 3), np.nan)
    out[0] = starting_point
    
    i = 1
    for theta, u in _gen_random_points_sphere(-(N // -segment_size)):
        if i == N:
            return out

        dx, dy, dz = (step_size * p for p in _spherical_to_cartesian(u, theta))
        d = np.vstack([dx, dy, dz]).T

        temp_p = [out[i - 1]] # initialize with last position in chain
        for step in range(1, segment_size + 1):
            new_p = temp_p[-1] + d
            if not constraint_f(new_p) or i + step > N:
                # break if new point violates constraint of this fills the last segment
                step -= 1
                break
            temp_p.append(new_p)

        if step > 0 and not (uniform_segment_lengths and len(temp_p) - 1 != segment_size) or i + len(temp_p) - 1 == N:
            # if uniform_segment_lengths: only add if whole segment is in constraint; or if this is the last segment
            out[i:i + step] = temp_p[1:]
            i += step
    

def grow_cubic(N, boxSize, method="standard"):
    """
    This function grows a ring or linear polymer on a cubic lattice 
    in the cubic box of size boxSize. 
    
    If method=="standard, grows a ring starting with a 4-monomer ring in the middle 
    
    if method =="extended", it grows a ring starting with a long ring 
    going from z=0, center of XY face, to z=boxSize center of XY face, and back. 
    
    If method="linear", then it grows a linearly organized chain from 0 to size.
    The chain may stick out of the box by one, (N%2 != boxSize%2), or be flush with the box otherwise

    Parameters
    ----------
    N: chain length. Must be even for rings. 
    boxSize: size of a box where polymer is generated.
    method: "standard", "linear" or "extended"


    """
    if N > boxSize ** 3:
        raise ValueError("Steps ahs to be less than size^3")
    if N > 0.9 * boxSize ** 3:
        warnings.warn("N > 0.9 * boxSize**3. It will be slow")
    if (N % 2 != 0) and (method != "linear"):
        raise ValueError("N has to be multiple of 2 for rings")

    t = boxSize // 2
    if method == "standard":
        a = [(t, t, t), (t, t, t + 1), (t, t + 1, t + 1), (t, t + 1, t)]

    elif method == "extended":
        a = []
        for i in range(1, boxSize):
            a.append((t, t, i))

        for i in range(boxSize - 1, 0, -1):
            a.append((t, t - 1, i))
        if len(a) > N:
            raise ValueError("polymer too short for the box size")

    elif method == "linear":
        a = []
        for i in range(0, boxSize + 1):
            a.append((t, t, i))
        if (len(a) % 2) != (N % 2):
            a = a[1:]
        if len(a) > N:
            raise ValueError("polymer too short for the box size")

    else:
        raise ValueError("select methon from standard, extended, or linear")

    b = np.zeros((boxSize + 2, boxSize + 2, boxSize + 2), int)
    for i in a:
        b[i] = 1

    for i in range((N - len(a)) // 2):
        while True:
            if method == "linear":
                t = np.random.randint(0, len(a) - 1)
            else:
                t = np.random.randint(0, len(a))

            if t != len(a) - 1:
                c = np.abs(np.array(a[t]) - np.array(a[t + 1]))
                t0 = np.array(a[t])
                t1 = np.array(a[t + 1])
            else:
                c = np.abs(np.array(a[t]) - np.array(a[0]))
                t0 = np.array(a[t])
                t1 = np.array(a[0])
            cur_direction = np.argmax(c)
            while True:
                direction = np.random.randint(0, 3)
                if direction != cur_direction:
                    break
            if np.random.random() > 0.5:
                shift = 1
            else:
                shift = -1
            shiftar = np.array([0, 0, 0])
            shiftar[direction] = shift
            t3 = t0 + shiftar
            t4 = t1 + shiftar
            if (
                (b[tuple(t3)] == 0)
                and (b[tuple(t4)] == 0)
                and (np.min(t3) >= 1)
                and (np.min(t4) >= 1)
                and (np.max(t3) < boxSize + 1)
                and (np.max(t4) < boxSize + 1)
            ):
                a.insert(t + 1, tuple(t3))
                a.insert(t + 2, tuple(t4))
                b[tuple(t3)] = 1
                b[tuple(t4)] = 1
                break
                # print a
    return np.array(a) - 1
